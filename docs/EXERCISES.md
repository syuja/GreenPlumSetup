![Greenplum](https://github.com/syuja/GreenPlumSetup/blob/master/img/greenplum-logo.png)  

## Exercises  

[Back to README.md](../README.md)  
[Go to ANALYTICS.md](./ANALYTICS.md)

### Table of Contents
  1. [VACUUM and ANALYZE](#vac)
  2. [Explain Plans](#expl)  
    a. [Changing Optimizers](#changing)
  3. [Indexes and Performance](#ind)
  4. [Rows vs. Column Orientation](#row)  
     a. [Guidelines Row for Column Orientation] (#choose)  
  5. [Even Data Distribution](#even)  
  6. [Partitioning] (#part)  
  7. [Summary] (#summary)

**Nota bene: the query optimizer is part of the query planner.**  

<a id="vac"></a>
#### VACUUM and ANALYZE
---  
Greenplum uses Multiversion Concurrency Control (MVCC) to guarantee isolation.
Isolationis a property of RDBMS that defines how/when the changes made by one operation become visible to others.<sup><a href="#fn1" id="ref1">1</a></sup>    

MVCC returns consistent query results for a query, even if data is changing as the query executes.
  - query sees snapshot of the database at a single point in time
  
`VACUUM:` removes rows that are no longer needed, **leaving free space that can be reused**.
  - row is updated or deleted, and no active transactions to it
  - produced by loading data while tables are in use

`ANALYZE:` generates statistics about the distribution of data in a table 
  - histograms about the values in each column
  - query optimizer uses for query plan selection
  
Query planner's optimizer attempts minmize volume of data that must be analyzed or moved. Having accurate statistics is important for this. **Run ANALYZE periodically or after major changes in the contents.**

```
psql -U gpadmin tutorial  
-- for every table, or can run ANALYZE on individual tables  
tutorial=# ANALYZE faa.d_airports;  
ANALYZE  
tutorial=# ANALYZE faa.d_airlines;  
ANALYZE
```
  
Summary: VACUUM removes unused rows therefore freeing space. ANALYZE generates statistics used by the query planner. Run both
after major changes have been made to the table.
  
<a id="expl"></a>
#### Explain Plans  
---  
An explain plan explains the method the optimizer has chosen to produce a result set. There can be several methods to produce
the result set, and the optimizer chooses the method with the lowest costs. Explain plans use statistics generated by ANALYZE.  

Read the plan from bottom to top. The cost number of each step has a start and stop value (stop value is fictional number). 
The cost number are cumulative, so the cost for the second operation includes the cost for the first one. Each operation is denoted
by `->`.   
    tutorial=# EXPLAIN SELECT COUNT(*) FROM sample WHERE id > 100;
    tutorial=# EXPLAIN ANALYZE SELECT COUNT(*) FROM sample WHERE id >100; --runs query without returning result  

<a id="changing"></a>
#### Change Optimizers  
By default, the Pivotal Query Optimizer (PQO) is disabled and legacy query optimizer is enabled. See EXPLAIN output under `optimizer staus`.  
    gpconfig -s optimizer -- check if PQO is enable  
    gpconfig -c optimizer -v on --masteronly -- enables PQO  
    gpstop -u -- reloads the configuration on master an segment instances  
     


<a id="ind"></a>
#### Indexes and Performance 
---  
Segments scan tables in parallel. Each segment contains a **small segment of the table**. Therefore, traditional performance advantage from indexes is diminished. Indexes consume space and require considerable CPU time.  

_Exception:_ Indexes are useful for highly selective queries. For example, looking up a single row.  
    
    tutorial=# SELECT * from sample WHERE big = 12345;
    Time: 197.640 ms
    tutorial=# EXPLAIN SELECT * from sample WHERE big = 12345;
    QUERY PLAN
    ...  
   Time: 19.719 ms  
    

Create index and run it again:  
    
    tutorial=# CREATE INDEX sample_big_index ON sample(big);
    CREATE INDEX
    Time: 1106.47 ms  
    
    tutorial=# EXPLAIN SELECT * FROM sample WHERE big = 12345;
    QUERY PLAN
    ...
    Time: 23.674
    
    --actual run
    tutorial=# SELECT * FROM sample WHERE big=12345;
    Time: 29.421 ms  
    

_Notice the difference in timing: 197 ms vs 29 ms. The difference is more pronounce for larger
tables._


<a id="row"></a>
#### Rows vs. Column Orientation 
---  
Both storage options have advantages, depending upon _data compression characteristics, 
the kinds of queries, row length, and complexity and number of joins_.  
[Generally](#choose), very wide tables are better in row orientation. Column orientation saves space with
compression and to reduce I/O when there is duplicated data on column.  
    to check size:
    tutorial=# SELECT pg_size_pretty(pg_relation_size('faa.otp_r'));
    tutorial=# SELECT pg_size_pretty(pg_relation_size('faa.otp_c'));

_Colum-oriented is append-only and partitioned._  

<a id="choose"></a>
#### Guidelines Row or Column Orientation<sup><a href="#fn2" id="ref2">2</a></sup>
|Row-oriented Storage | Column-oriented Storage|
|---------------------|------------------------|
|OLTP                 |OLAP                   |
|many columns of single row needed at once | aggregation of small number of columns or for single columns requires regular updates|  

**Scenarios:**  
Update tables of data frequently: row oriented   
Frequent inserts: column oriented must write to different places on disk    
Number of Columns requested: request all or majority then row-oriented  
Number of columns in table: row-oriented best for many columns.  

Use column-oriented when **aggregate** many values of a single column, when the row-size is
small or accessing a small subset of the columns. Columns have the same data type, so they can
be compressed when stored in column-orientation.  

more [info] (http://gpdb.docs.pivotal.io/4380/admin_guide/ddl/ddl-storage.html#topic39)


<a id="even"></a>
#### Even Data Distribution  
---  
**Check for even data distribution on segments.**  

The tables are distributed with a hash function on UniqueCarrier and FlightNum. These columns 
were selected because they produce even distribution of data onto segments. Also, frequent joins
are expected on these two columns. Try to distribute based on a unique column, since this 
ensures an even distribution. **Low cardinality columns will yield poor distribution.**  

One goal is to ensure approximately same amount of data in each segment.  
    tutorial=# SELECT gp_segment_id, COUNT(*) FROM faa.otp_c GROUP BY
    gp_segment_id ORDER BY gp_segment_id;


<a id="part"></a>
#### Partitioning 
---  
Partitioning is like indexing, but at a higher level. Partitioning tables can improve query performance by allowing the query optimizer to scan only
the needed data to satisfy the query. Partioning is logical not physical, and the table is divided
into smaller child files.  

Why does it increase performance? When a query filters on same criteria used to define partitions, the 
optimizer can avoid searching irrelevant partitions. 

Two types:  
  A. range partitioning: division based on range, such as date or price  
  B. list partitioning: based on a list of values, such as territory or product line  
  C. combination of both types  
  
  <p align = "center">
![partition] (https://github.com/syuja/GreenPlumSetup/blob/master/img/partition.png)
  </p>

Partitioning occurs during CREATE TABLE PARTITION BY. When a new partition is added, run ANALYZE
again. Can either run ANALYZE on root partition or simply the new partition.  

    
    tutorial=#\timing on
    tutorial=# SELECT MAX(depdelay) FROM faa.otp_c WHERE UniqueCarrier='UA';
    --not partitioned by unique carrier
    Time: 641.574 ms
    
    tutorial=# SELECT MAX(depdelay) FROM faa.otp_c WHERE flightdate='2009-11-01';
    Time: 30.658 ms
      

The query on the partitioned column(flightdate) takes much less time. First scan, scans all
17 children, while the second one just scans one child file.  

For more info on [partitions]. (http://gpdb.docs.pivotal.io/4350/admin_guide/ddl/ddl-partition.html)  

<a id="summary"></a>
###Summary:  
---  
In order for Greenplum to run efficiently it is important to run VACUUM and ANALYZE periodically.  

This will affect the query plan chosen by the optimizer. The user may want to consider changing the optimizer to use QPO, instead of the default optimizer.  

Don't add indices unless you plan to query very specific rows of data.  

When creating a table, consider using column-orientation according to our guidelines.  

Ensure that the data is distributed evenly across segments. 

Finally, partition the tables, particularly if plan use queries that filter results using WHERE. Create partitions corresponding to the filters that will be used.    

#### [ANALYTICS.md](./ANALYTICS.md)
---
<sup id="fn1"><a href="#ref1" title="jump back">1:For isolation, there is a tradeoff between concurrency and concurrency effect (dirty reads, lost updates). More isolation results in
less concurrency and less concurrency effects.</a></sup>  
<sup id="fn2"> <a href="#ref2" title="guidelines"> 2:</a></sup> <http://gpdb.docs.pivotal.io/4380/admin_guide/ddl/ddl-storage.html>  

  
  
